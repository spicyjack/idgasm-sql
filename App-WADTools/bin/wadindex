#!/usr/bin/perl -w

# For support with this file, please file an issue on the GitHub issue tracker
# for this project: https://github.com/spicyjack/wadtools/issues

=head1 NAME

B<wadindex> - Create an index and/or catalog of WAD files using files stored
on a local machine

=cut

our $copyright = (
    q|Copyright (c) 2013 by Brian Manning/brian at xaoc dot org|
);

=head1 SYNOPSIS

 perl wadindex [OPTIONS]

 Script options:
 -h|--help          Shows this help text
 -d|--debug         Debug script execution (tons of output)
 -c|--colorize      Always colorize script output
 -v|--verbose       Verbose script execution
 --version          Print script version and copyright, then exit

 Path/database options:
 -p|--path          Path to WAD files/directories with WAD files
 --strip-path       Strip this string out of log output
 -t|--tempdir       Temporary directory to use when unzipping WAD files
 -b|--database      Path to database created with 'idgames_db_dump'

 Debug options:
 --debug-noexit     Don't exit script when --debug is used
 --debug-requests   Exit after this many files when --debug used

 Example usage:

 # walk a directory structure full of '*.zip' files and index
 wadindex --path /path/to/wad/files --tempdir /dev/shm

 # run wadindex with debugging output, process 100 zip/non-zip files,
 # then exit
 wadindex --path /path/to/wad/files --tempdir /dev/shm \
  --debug --debug-requests 100

 # Strip a string out of the --path argument;
 # good for traversing a local mirror of idGames Archive
 wadindex --path /real/long/path/to/idgames/archive \
    --strip-path "/real/long/path/to"


You can view the full C<POD> documentation of this file by calling C<perldoc
wadindex>.

=cut

our @options = (
    # script options
    q(debug|d),
    q(verbose|v),
    q(version),
    q(help|h),
    q(colorize|c), # ignore '-t' test and always colorize output

    # path/db options
    q(path|p=s),
    q(strip-path=s),
    q(tempdir|t=s),
    q(database|db|b=s),

    # debug options
    q(debug-noexit),
    q(debug-requests=i),
);

=head1 DESCRIPTION

Given a directory with WAD files (or WAD files zipped up
inside of '.zip' files), create an index that contains:

=over

=item The name of the WAD file

=item What levels that WAD file contains

=item The WAD's author

=item The WAD's checksum

=item The WAD's average rating on Doomworld

=back

=cut

################
# package main #
################
package main;
use 5.010;
use strict;
use warnings;
use utf8;

### System modules
use Carp;
use Data::Dumper;
$Data::Dumper::Indent = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Terse = 1;
use Fcntl;
use File::Basename;
use File::Find::Rule;
#use File::LibMagic;
use File::Temp;
use IO::File;
use Log::Log4perl qw(get_logger :no_extra_logdie_message);
use Log::Log4perl::Level;
use Pod::Usage;

### Local modules
use App::WADTools::Config;
use App::WADTools::Database;
use App::WADTools::WADIndexer;
use App::WADTools::ZipTool;

# FIXME: GitHub issue #83, create a MIME magic preflight check
# WARNING: these will change depending on which 'magic' file you're looking at
use constant {
    OCTET_STREAM => q(application/octet-stream;),
    TEXT_PLAIN   => q(text/plain; charset=),
    ZIP        => q(application/zip; charset=binary),
};

    # create a variable with the current name of the script
    my $my_name = basename($0);
    # provide a version string if dzil hasn't populated modules with $VERSION
    # scalars
    my $VERSION = $App::WADTools::VERSION || q(git-dev);

    # allow UTF-8 output
    binmode(STDOUT, ":utf8");

    # create a logger object
    my $cfg = App::WADTools::Config->new(options => \@options);

    # dump and bail if we get called with --help
    if ( $cfg->defined(q(help)) ) { pod2usage(-exitstatus => 1); }

    if ( $cfg->defined(q(version)) ) {
        print STDERR qq($my_name: version '$VERSION'\n);
        print STDERR qq($my_name: $copyright\n);
        exit 0;
    }

    if ( ! $cfg->defined(q(tempdir)) ) {
        $cfg->set(q(tempdir), q(/dev/shm));
    }
    # set up the logger
    my $log_conf;
    if ( $cfg->defined(q(debug)) ) {
        $log_conf = qq(log4perl.rootLogger = DEBUG, Screen\n);
    } elsif ( $cfg->defined(q(verbose)) ) {
        $log_conf = qq(log4perl.rootLogger = INFO, Screen\n);
    } else {
        $log_conf = qq(log4perl.rootLogger = WARN, Screen\n);
    }

    if ( -t STDOUT || $cfg->defined(q(colorize)) ) {
        $log_conf .= qq(log4perl.appender.Screen = )
            . qq(Log::Log4perl::Appender::ScreenColoredLevels\n);
    } else {
       $log_conf .= qq(log4perl.appender.Screen = )
            . qq(Log::Log4perl::Appender::Screen\n);
    }

    $log_conf .= qq(log4perl.appender.Screen.stderr = 1\n)
        . qq(log4perl.appender.Screen.utf8 = 1\n)
        . qq(log4perl.appender.Screen.layout = PatternLayout\n)
        . q(log4perl.appender.Screen.layout.ConversionPattern )
        # %r: number of milliseconds elapsed since program start
        # %p{1}: first letter of event priority
        # %4L: line number where log statement was used, four numbers wide
        # %M{1}: Name of the method name where logging request was issued
        # %m: message
        # %n: newline
        . qq|= [%6r] %p{1} %4L (%M{1}) %m%n\n|;
        #. qq( = %d %p %m%n\n)
        #. qq(= %d{HH.mm.ss} %p -> %m%n\n);

    # create a logger object, and prime the logfile for this session
    Log::Log4perl::init( \$log_conf );
    my $log = get_logger("");

    $log->logdie(qq(Missing '--path' directory argument))
        unless ( $cfg->defined(q(path)) );
    my $wad_path = $cfg->get(q(path));
    $log->logdie(qq('--path' )
        . $cfg->get(q(path)) . q( not found/available))
        unless ( -r $wad_path );

    # check for the database file if --database was used
    if ( $cfg->defined(q(database)) ) {
        $log->logdie(qq(Can't find database file ) . $cfg->get(q(database)))
            unless ( -e $cfg->get(q(database)) );
    }

    # print a nice banner
    $log->warn(qq(Starting $my_name, version '$VERSION'));
    $log->warn($copyright);
    $log->warn(qq(My PID is $$));
    $log->warn(qq(Searching for ZIP files in: $wad_path));

    my $zip_file_counter = 0;
    my $total_file_counter = 0;
    my $indexer = App::WADTools::WADIndexer->new();
    my $db = App::WADTools::Database->new(filename => $cfg->get(q(database)));
    my @files = File::Find::Rule
                        ->file
                        #->name(q(*.wad), q(*.zip))
                        ->in($wad_path);
    FILE_LOOP: foreach my $found_file ( sort(@files) ) {
        $total_file_counter++;
        last FILE_LOOP if ( $cfg->defined(q(debug-requests))
            && $total_file_counter > $cfg->get(q(debug-requests)) );
        my $filename = basename($found_file);
        my $dirname = dirname($found_file);
        my $file_path = $dirname . q(/) . $filename;
        if ( $cfg->defined(q(strip-path)) ) {
            my $strip_path = $cfg->get(q(strip-path));
            #$log->debug(qq('strip-path' is $strip_path));
            my $short_path = $dirname;
            $short_path =~ s/^$strip_path//;
            #$log->debug(qq(Setting short_path to $short_path));
            $file_path = qq($short_path/$filename);
        }
        $log->warn(qq(File: $file_path));
        if ( $filename =~ /\.zip$/ ) {
            my $zipfile = App::WADTools::ZipTool->new(
                cfg => $cfg,
                filename => $found_file,
            );
            my @members = $zipfile->get_zip_members();
            my @wads_in_zip = grep(/\.wad/i, @members);
            if ( scalar(@wads_in_zip) > 0 ) {
                $log->info(q(Extracting ) . scalar(@wads_in_zip)
                    . qq( WADs from zipfile '$filename'));
                my $temp_dir = $zipfile->extract_files(files => \@wads_in_zip);
                $indexer->index(tempdir => $temp_dir, files => \@wads_in_zip);
            } else {
                $log->info(qq(No *.wad files in $file_path));
            }
            $zip_file_counter++;
        } else {
            $log->info(qq(Not a zip file: $filename));
        }
        $log->warn(qq(Finished processing: $file_path));
    }

=head1 AUTHOR

Brian Manning, C<< <brian at xaoc dot org> >>

=head1 BUGS

Please report any bugs or feature requests to the GitHub issue tracker for
this project:

C<< <https://github.com/spicyjack/wadtools/issues> >>.

=head1 SUPPORT

You can find documentation for this script with the perldoc command.

    perldoc wadindex

=head1 COPYRIGHT & LICENSE

Copyright (c) 2013 Brian Manning, all rights reserved.

This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.

=cut

# fin!
# vim: set shiftwidth=4 tabstop=4
